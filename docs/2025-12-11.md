# Next

Implement movement for local player.

## Local player

### Common

- Distinguish between snapshots and `InitialData` (maze, player names, ...).
- Consider set-up of buffers with default items for initial tick 0, how it will move on from there, and consequences of edge cases. Make sure it won't result in visual glitches, e.g. while interpolating. We should have initial data well before displaying anything, though, and are already bailing out if it's not available.

### Client

- @client/src/game/input.rs
  - Repace old `InputHistory` struct with a `Ring<PlayerInput, 256>`.
- Calculate future tick number on which we want the server to process the current input.
  - Where does this belong: run or game handler or game state update?
- @client/src/game/state.rs
  - Replace placeholder index 0 with actual `current_tick`.
  - Add latest input to `input_history`.
  - Reconcile and predict. Since inputs are needed for two things--prediction and redundant sending--just rely on tick ids rather than `Option`.
- Implement `snapshot_buffer` as a `RingBuffer<Snapshot, 16>`.

### Server

- Implement an input buffer for each client as a `NetworkBuffer<PlayerInput, 128>`.
- Get current tick number from time.
- Create input buffers for each player present at the start of the game.
  - Keep players in `Vec` after death, but send them a minimal snapshot with just player positions and death events?
- On each tick, check for unreliable input messages and insert any received into the appropriate input buffer at the appropriate index.
- Get the inputs for this tick, if available, and use the most recent valid input if not. Apply them all to the current game state and send the resulting new snapshot to all players. (Possible an abbeviated snapshot to dead players, but don't worry about this for now; just send the whole thing.)

## Other

- Make style consistent: choose just one out of `i`, `idx`, or `index` for indices in a narrow context.
- Remove superfluous getters and setters everywhere.
