# Next

Implement movement for local player. Originally, I thought that, as a first step, I could just set it up with one initial snapshot and have the client predict from there. But no, the amount of prediction each frame would increase without bound. Instead I'll try to write the whole system, with just the local p;ayer at first, in one step, reconciliation and server logic included.

### Client

- @client/src/game/input.rs
  - Repace `InputHistory` struct with an array `input_history: [PlayerInput; 256]`.
- Calculate future tick number on which we want the server to process the current input.
  - Where does this belong: run or game handler or game state update?
  - @client/src/game/state.rs Replace placeholder index 0 with actual `current_tick`.
- @client/src/game/state.rs
  - Add latest input to `input-buffer`.
  - Reconcile and predict. Since inputs are needed for two things--prediction and redundant sending--just rely on tick ids rather than `Option`.

### Server

- Get current tick number from time.
- Create input buffers for each player present at the start of the game.
  - Keep players in `Vec` after death, but send them a minimal snapshot with just player positions and death events?
- On each tick, check for unreliable input messages and insert any received into the appropriate input buffer at the appropriate index.
- Get the inputs for this tick, if available, and use the most recent valid input if not. Apply them all to the current game state and send the resulting new snapshot to all players. (Possible an abbeviated snapshot to dead players, but don't worry about this for now; just send the whole thing.)
