# Next

- If you try to to connect after the countdown has started, the program should notify you and disconnect you. At present the server just prints a message in its terminal claming to have done that, but all the client sees is, "Waiting for server..." indefinitely.
- Make sure disconnect messages are all styled consistent and according to my guide, both in UI and terminal.

Then handle movement for local player. Originally, I thought that, as a first step, I could just set it up with one initial snapshot and have the client predict from there. But no, the amount of prediction each frame would increase without bound. Maybe I should just try to write the whole system, with just the local p;ayer at first, in one step, reconciliation and server logic included.

### Common

- @common/src/snapshot.rs
  - Turn the current `Snapshot` struct into an `InitialData` struct for maze and players to be sent reliably at the start of the countdown.
  - Create a new `Snapshot` struct to send and store player data that will change in game. Simplest to send player data as a `Vec` for now rather than faffing around with bitfields; I can always make it an array later if needed.

### Client

- @client/src/game/input.rs
  - Repace `InputHistory` struct with an array `input_history: [PlayerInput; 256]`.
- Calculate future tick number on which we want the server to process the current input.
  - Where does this belong: run or game handler or game state update?
  - @client/src/game/state.rs Replace placeholder index 0 with actual `current_tick`.
- @client/src/game/state.rs
  - Add latest input to `input-buffer`.
  - Reconcile and predict. Since inputs are needed for two things--prediction and redundant sending--just rely on tick ids rather than `Option`.

### Server

- Get current tick number from time.
- Create input buffers for each player present at the start of the game.
  - Keep players in `Vec` after death, but send them a minimal snapshot with just player positions and death events?
- On each tick, check for unreliable input messages and insert any received into the appropriate input buffer at the appropriate index.
- Get the inputs for this tick, if available, and use the most recent valid input if not. Apply them all to the current game state and send the resulting new snapshot to all players. (Possible an abbeviated snapshot to dead players, but don't worry about this for now; just send the whole thing.)
